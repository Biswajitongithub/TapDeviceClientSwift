//
// SinglePacketAPI.swift
//
// Generated by iotize device api codegen
//

import Foundation
import TapClientApi
// 



open class SinglePacketAPI {

    var client: TapClient
    var converterProvider: ConverterProvider

    init(client: TapClient, converterProvider: ConverterProvider){
        self.client = client
        self.converterProvider = converterProvider
    }

    /**
    * Execute (after validation) a big Single Packet previously sent to the TAP using BSPP.
    * Execute (after validation) a big Single Packet previously sent to the TAP using BSPP.  Stored packet is erased after packet is executed. (even if failed to execute) This command contains some control information (size, hash, CRC, salt, etc.) TBD
    * LWM2M path: /1024//83
    * Body converter id: "Bytes"

    * @param data input
    * @return Bytes api call
    */
    public func bspeRequest(
        data: Bytes
    ) -> ApiRequest<Bytes>{
        var path = "/1024//83"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.POST
            , path: path
            , body: data
            , bodyEncoder: self.converterProvider.get(id: "Bytes")
        )
    }

     /**
        * Execute (after validation) a big Single Packet previously sent to the TAP using BSPP.
        * Execute (after validation) a big Single Packet previously sent to the TAP using BSPP.  Stored packet is erased after packet is executed. (even if failed to execute) This command contains some control information (size, hash, CRC, salt, etc.) TBD
        * LWM2M path: /1024//83
        * Body converter id: "Bytes"
    
        * @param data input
        * @return Bytes api call
        */
        public func bspe(
            data: Bytes
        ) throws -> ApiResponse<Bytes>{
            let request : ApiRequest<Bytes> = self.bspeRequest(data: data)
            let converter: TapConverterContainer<Bytes> = self.converterProvider.get(id: "Bytes")
            let response: ApiResponse<Bytes> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * Get information concerning Single Packet Store Status
    * Get information concerning Single Packet Store Status : Does this TAP provide the Single Packet Store ? (SPS) Is the store empty, full or halfway ? Details about the the execution of the last executes SP ?
    * LWM2M path: /1024//80
    * @return Bytes api call
    */
    public func getInfoRequest()
         -> ApiRequest<Void>{
        var path = "/1024//80"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
        )
    }

     /**
        * Get information concerning Single Packet Store Status
        * Get information concerning Single Packet Store Status : Does this TAP provide the Single Packet Store ? (SPS) Is the store empty, full or halfway ? Details about the the execution of the last executes SP ?
        * LWM2M path: /1024//80
                * @return Bytes api call
        */
        public func getInfo()
             throws -> ApiResponse<Bytes>{
            let request : ApiRequest<Void> = self.getInfoRequest()
            let converter: TapConverterContainer<Bytes> = self.converterProvider.get(id: "Bytes")
            let response: ApiResponse<Bytes> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * Send a partial Single Packet to the TAP.
    * Size of the packet &#x3D; 130 bytes : 2 bytes offset, 128 bytes packet part. Stored packet is erased when packet part 0 is received.
    * LWM2M path: /1024//82
    * Body converter id: "Bytes"

    * @param data input
    * @return Bytes api call
    */
    public func writePartialSinglePacketRequest(
        data: Bytes
    ) -> ApiRequest<Bytes>{
        var path = "/1024//82"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.POST
            , path: path
            , body: data
            , bodyEncoder: self.converterProvider.get(id: "Bytes")
        )
    }

     /**
        * Send a partial Single Packet to the TAP.
        * Size of the packet &#x3D; 130 bytes : 2 bytes offset, 128 bytes packet part. Stored packet is erased when packet part 0 is received.
        * LWM2M path: /1024//82
        * Body converter id: "Bytes"
    
        * @param data input
        * @return Bytes api call
        */
        public func writePartialSinglePacket(
            data: Bytes
        ) throws -> ApiResponse<Bytes>{
            let request : ApiRequest<Bytes> = self.writePartialSinglePacketRequest(data: data)
            let converter: TapConverterContainer<Bytes> = self.converterProvider.get(id: "Bytes")
            let response: ApiResponse<Bytes> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * Send a complete Small Single Packet to the TAP. Size of the packet &lt; 120 bytes
    * 
    * LWM2M path: /1024//80
    * Body converter id: "Bytes"

    * @param data input
    * @return Bytes api call
    */
    public func writeSmallSinglePacketRequest(
        data: Bytes
    ) -> ApiRequest<Bytes>{
        var path = "/1024//80"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.POST
            , path: path
            , body: data
            , bodyEncoder: self.converterProvider.get(id: "Bytes")
        )
    }

     /**
        * Send a complete Small Single Packet to the TAP. Size of the packet &lt; 120 bytes
        * 
        * LWM2M path: /1024//80
        * Body converter id: "Bytes"
    
        * @param data input
        * @return Bytes api call
        */
        public func writeSmallSinglePacket(
            data: Bytes
        ) throws -> ApiResponse<Bytes>{
            let request : ApiRequest<Bytes> = self.writeSmallSinglePacketRequest(data: data)
            let converter: TapConverterContainer<Bytes> = self.converterProvider.get(id: "Bytes")
            let response: ApiResponse<Bytes> = try self.client.execute(request: request, converter: converter)

            return response
        }

}
