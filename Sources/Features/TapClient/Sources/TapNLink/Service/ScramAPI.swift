//
// ScramAPI.swift
//
// Generated by iotize device api codegen
//

import Foundation
import TapClientApi
// 



open class ScramAPI {

    var client: TapClient
    var converterProvider: ConverterProvider

    init(client: TapClient, converterProvider: ConverterProvider){
        self.client = client
        self.converterProvider = converterProvider
    }

    /**
    * Get scram hash it
    * Scram conf iteration counter (i) to be read by client before starting scram login process
    * LWM2M path: /1024//42
    * @return  api call
    */
    public func getScramHashItRequest()
         -> ApiRequest<Void>{
        var path = "/1024//42"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
        )
    }

     /**
        * Get scram hash it
        * Scram conf iteration counter (i) to be read by client before starting scram login process
        * LWM2M path: /1024//42
                * @return  api call
        */
        public func getScramHashIt()
             throws -> ApiResponse<Void>{
            let request : ApiRequest<Void> = self.getScramHashItRequest()
            
            let response: ApiResponse<Void> = try self.client.execute(request: request)

            return response
        }
    /**
    * Get scram user iteration
    * SCRAM Hash Iteration: Nombre d&#39;itérations utilisé en SCRAM pour le dernier hashage. Nombre &gt;1000, généré aléatoirement à l&#39;écriture de la conf dans l&#39;IoTize.
    * LWM2M path: /1025/{groupId}/7

    * @param groupId input
    * @return UInt32 api call
    */
    public func getScramUserIterationRequest(
        groupId: Int8
    ) -> ApiRequest<Void>{
        var path = "/1025/{groupId}/7"
        //var regex = "\{([\S]*)\}"
        
        path = path.replacingOccurrences(of: "{"+"groupId"+"}", with: String(groupId))
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
            
        )
    }

     /**
        * Get scram user iteration
        * SCRAM Hash Iteration: Nombre d&#39;itérations utilisé en SCRAM pour le dernier hashage. Nombre &gt;1000, généré aléatoirement à l&#39;écriture de la conf dans l&#39;IoTize.
        * LWM2M path: /1025/{groupId}/7
        
        * @param groupId input
        * @return UInt32 api call
        */
        public func getScramUserIteration(
            groupId: Int8
        ) throws -> ApiResponse<UInt32>{
            let request : ApiRequest<Void> = self.getScramUserIterationRequest(groupId: groupId)
            let converter: TapConverterContainer<UInt32> = self.converterProvider.get(id: "integer_uint32")
            let response: ApiResponse<UInt32> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * Get scram user salt
    * User-specific salt utilisé (avec le User Name) pour saller les hashs du password StoredKey et ServerKey. Ecrit par Exec/SetPWD
    * LWM2M path: /1025/{groupId}/16

    * @param groupId input
    * @return UInt32 api call
    */
    public func getScramUserSaltRequest(
        groupId: Int8
    ) -> ApiRequest<Void>{
        var path = "/1025/{groupId}/16"
        //var regex = "\{([\S]*)\}"
        
        path = path.replacingOccurrences(of: "{"+"groupId"+"}", with: String(groupId))
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
            
        )
    }

     /**
        * Get scram user salt
        * User-specific salt utilisé (avec le User Name) pour saller les hashs du password StoredKey et ServerKey. Ecrit par Exec/SetPWD
        * LWM2M path: /1025/{groupId}/16
        
        * @param groupId input
        * @return UInt32 api call
        */
        public func getScramUserSalt(
            groupId: Int8
        ) throws -> ApiResponse<UInt32>{
            let request : ApiRequest<Void> = self.getScramUserSaltRequest(groupId: groupId)
            let converter: TapConverterContainer<UInt32> = self.converterProvider.get(id: "integer_uint32")
            let response: ApiResponse<UInt32> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * Start scram communication
    * Demande d&#39;une clé aléatoire et initiation d&#39;une session CCOM cryptée utilisant ce RNG comme clé de cryptage. Accessible uniquement en NFC.
    * LWM2M path: /1024//47
    * @return Bytes api call
    */
    public func initializeRequest()
         -> ApiRequest<Void>{
        var path = "/1024//47"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
        )
    }

     /**
        * Start scram communication
        * Demande d&#39;une clé aléatoire et initiation d&#39;une session CCOM cryptée utilisant ce RNG comme clé de cryptage. Accessible uniquement en NFC.
        * LWM2M path: /1024//47
                * @return Bytes api call
        */
        public func initialize()
             throws -> ApiResponse<Bytes>{
            let request : ApiRequest<Void> = self.initializeRequest()
            let converter: TapConverterContainer<Bytes> = self.converterProvider.get(id: "Bytes")
            let response: ApiResponse<Bytes> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * First command to initiate scram login, for client to send login and nonce to IoTize, and IoTize to return user salt, user iteration counter (j) and combined nonce
    * First command to initiate scram login, for client to send login and nonce to IoTize, and IoTize to return user salt, user iteration counter (j) and combined nonce
    * LWM2M path: /1024//40
    * Body converter id: "ScramLoginParams"

    * @param params input
    * @return ScramLoginResponseBody api call
    */
    public func loginRequest(
        params: ScramLoginParams? = nil
    ) -> ApiRequest<ScramLoginParams>{
        var path = "/1024//40"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
            , body: params
            , bodyEncoder: self.converterProvider.get(id: "ScramLoginParams")
        )
    }

     /**
        * First command to initiate scram login, for client to send login and nonce to IoTize, and IoTize to return user salt, user iteration counter (j) and combined nonce
        * First command to initiate scram login, for client to send login and nonce to IoTize, and IoTize to return user salt, user iteration counter (j) and combined nonce
        * LWM2M path: /1024//40
        * Body converter id: "ScramLoginParams"
    
        * @param params input
        * @return ScramLoginResponseBody api call
        */
        public func login(
            params: ScramLoginParams? = nil
        ) throws -> ApiResponse<ScramLoginResponseBody>{
            let request : ApiRequest<ScramLoginParams> = self.loginRequest(params: params)
            let converter: TapConverterContainer<ScramLoginResponseBody> = self.converterProvider.get(id: "ScramLoginResponseBody")
            let response: ApiResponse<ScramLoginResponseBody> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * Scram login proof
    * Second command to finalize scram login, for client to send ClientProof and combined nonce
    * LWM2M path: /1024//41
    * Body converter id: "Bytes"

    * @param params input
    * @return Bytes api call
    */
    public func loginProofRequest(
        params: Bytes? = nil
    ) -> ApiRequest<Bytes>{
        var path = "/1024//41"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
            , body: params
            , bodyEncoder: self.converterProvider.get(id: "Bytes")
        )
    }

     /**
        * Scram login proof
        * Second command to finalize scram login, for client to send ClientProof and combined nonce
        * LWM2M path: /1024//41
        * Body converter id: "Bytes"
    
        * @param params input
        * @return Bytes api call
        */
        public func loginProof(
            params: Bytes? = nil
        ) throws -> ApiResponse<Bytes>{
            let request : ApiRequest<Bytes> = self.loginProofRequest(params: params)
            let converter: TapConverterContainer<Bytes> = self.converterProvider.get(id: "Bytes")
            let response: ApiResponse<Bytes> = try self.client.execute(request: request, converter: converter)

            return response
        }
    /**
    * Write scram user iteration
    * 
    * LWM2M path: /1025/{groupId}/7
    * Body converter id: "integer_uint32"

    * @param groupId input

    * @param value input
    * @return  api call
    */
    public func putScramUserIterationRequest(
        groupId: Int8, value: UInt32? = nil
    ) -> ApiRequest<UInt32>{
        var path = "/1025/{groupId}/7"
        //var regex = "\{([\S]*)\}"
        
        path = path.replacingOccurrences(of: "{"+"groupId"+"}", with: String(groupId))
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.PUT
            , path: path
            
            , body: value
            , bodyEncoder: self.converterProvider.get(id: "integer_uint32")
        )
    }

     /**
        * Write scram user iteration
        * 
        * LWM2M path: /1025/{groupId}/7
        * Body converter id: "integer_uint32"
    
        * @param groupId input

        * @param value input
        * @return  api call
        */
        public func putScramUserIteration(
            groupId: Int8, value: UInt32? = nil
        ) throws -> ApiResponse<Void>{
            let request : ApiRequest<UInt32> = self.putScramUserIterationRequest(groupId: groupId, value: value)
            
            let response: ApiResponse<Void> = try self.client.execute(request: request)

            return response
        }
    /**
    * Write scram user salt
    * 
    * LWM2M path: /1025/{groupId}/16
    * Body converter id: "integer_uint32"

    * @param groupId input

    * @param value input
    * @return  api call
    */
    public func putScramUserSaltRequest(
        groupId: Int8, value: UInt32? = nil
    ) -> ApiRequest<UInt32>{
        var path = "/1025/{groupId}/16"
        //var regex = "\{([\S]*)\}"
        
        path = path.replacingOccurrences(of: "{"+"groupId"+"}", with: String(groupId))
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.PUT
            , path: path
            
            , body: value
            , bodyEncoder: self.converterProvider.get(id: "integer_uint32")
        )
    }

     /**
        * Write scram user salt
        * 
        * LWM2M path: /1025/{groupId}/16
        * Body converter id: "integer_uint32"
    
        * @param groupId input

        * @param value input
        * @return  api call
        */
        public func putScramUserSalt(
            groupId: Int8, value: UInt32? = nil
        ) throws -> ApiResponse<Void>{
            let request : ApiRequest<UInt32> = self.putScramUserSaltRequest(groupId: groupId, value: value)
            
            let response: ApiResponse<Void> = try self.client.execute(request: request)

            return response
        }
    /**
    * Communication channel
    * Crypted communication ressource, for sending/receiving commands/responses after the SCRAM or CCOM session is established.
    * LWM2M path: /1024//48
    * Body converter id: "Bytes"

    * @param data input
    * @return Bytes api call
    */
    public func sendRequest(
        data: Bytes
    ) -> ApiRequest<Bytes>{
        var path = "/1024//48"
        //var regex = "\{([\S]*)\}"
        

        return ApiRequest(
            method: TapRequestHeader.MethodType.GET
            , path: path
            , body: data
            , bodyEncoder: self.converterProvider.get(id: "Bytes")
        )
    }

     /**
        * Communication channel
        * Crypted communication ressource, for sending/receiving commands/responses after the SCRAM or CCOM session is established.
        * LWM2M path: /1024//48
        * Body converter id: "Bytes"
    
        * @param data input
        * @return Bytes api call
        */
        public func send(
            data: Bytes
        ) throws -> ApiResponse<Bytes>{
            let request : ApiRequest<Bytes> = self.sendRequest(data: data)
            let converter: TapConverterContainer<Bytes> = self.converterProvider.get(id: "Bytes")
            let response: ApiResponse<Bytes> = try self.client.execute(request: request, converter: converter)

            return response
        }

}
